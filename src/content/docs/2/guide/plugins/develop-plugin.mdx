---
title: Develop a Tauri Plugin
---

## Exposing Rust APIs

The plugin APIs defined in your project's `desktop.rs` and `mobile.rs` are exported to the users as a struct with the same name as your plugin, in pascal case. When the plugin is setup, an instance of this struct is created and managed as a state so users can retrieve it at any point of time with a Manager instance (an AppHandle, App or Window instance) through the extension trait defined in the plugin.

For instance, the global-shortcut plugin defines a GlobalShortcut struct that can be read by using the `global_shortcut` method of the `GlobalShortcutExt` trait:

```rust
use tauri_plugin_global_shortcut::GlobalShortcutExt;

tauri::Builder::default()
  .plugin(tauri_plugin_global_shortcut::init())
  .setup(|app| {
    app.global_shortcut().register(...);
    Ok(())
  })
```

### Desktop vs Mobile Implementations

The default template splits the plugin's implementation into two separate modules, `desktop.rs` and `mobile.rs`.

The desktop implementation uses Rust code to implement a functionality, while the mobile one sends a message to the native mobile code to execute a function and get a result back. If you need to share logic across both implementations, you can define shared functions on `lib.rs`:

```rust
use tauri::Runtime;

impl<R: Runtime> <your-plugin-name-here;pascal-case><R> {
  pub fn do_something(&self) {
    // do something that is a shared implementation between desktop and mobile
  }
}
```

This implementation simplifies the process of sharing an API that can be used both by commands and Rust code.

## Mobile

Plugins can run native mobile code written in Kotlin (or Java) and Swift. The default plugin template includes an Android library project using Kotlin and a Swift package including an example mobile command and how to trigger its execution from Rust code.

### Adding Mobile Support to an Existing Plugin

If you have an existing plugin and would like to add Android or iOS capabilities to it, you can use the [`plugin android add`](/2/reference/cli#plugin-android-add) and [`plugin ios add`](/2/reference/cli#plugin-ios-add) commands to bootstrap the mobile library projects and guide you through the changes needed.

Alternatively, consider bootstrapping a new plugin template with the v2 CLI which by default includes all code required to run native mobile code on a plugin.

### Android

For the complete documentation on writing Android plugins, see [the guide](./develop-plugin-android).

### iOS

For the complete documentation on writing iOS plugins, see [the guide](./develop-plugin-ios).

### Adding Commands on Mobile

Inside the respective mobile projects, you will find a plugin class where you can define commands that can be called by the Rust code.

- Android

```java
@TauriPlugin
class ExamplePlugin(private val activity: Activity): Plugin(activity) {
  @Command
  fun openCamera(invoke: Invoke) {
    val allowEdit = invoke.getBoolean("allowEdit", false)
    val quality = invoke.getInt("quality", 100)

    val ret = JSObject()
    ret.put("path", "/path/to/photo.jpg")
    invoke.resolve(ret)
  }
}
```

- iOS

```swift
class ExamplePlugin: Plugin {
	@objc public func openCamera(_ invoke: Invoke) {
    let allowEdit = invoke.getBool("allowEdit", false)
    let quality = invoke.getInt("quality", 100)

    invoke.resolve(["path": "/path/to/photo.jpg"])
	}
}
```

### Calling Mobile Commands

Your plugin API struct stores a [`tauri::plugin::PluginHandle`](https://docs.rs/tauri/2.0.0-alpha/tauri/plugin/struct.PluginHandle.html) that can be used to call a mobile command:

```rust
use std::path::PathBuf;
use serde::{Deserialize, Serialize};
use tauri::Runtime;

#[derive(Serialize)]
#[serde(rename_all = "camelCase")]
pub struct CameraRequest {
  quality: usize,
  allow_edit: bool,
}

#[derive(Deserialize)]
pub struct Photo {
  path: PathBuf,
}


impl<R: Runtime> <your-plugin-name-here;pascal-case><R> {
  pub fn open_camera(&self, payload: CameraRequest) -> crate::Result<Photo> {
    self
      .0
      .run_mobile_plugin("openCamera", payload)
      .map_err(Into::into)
  }
}
```
