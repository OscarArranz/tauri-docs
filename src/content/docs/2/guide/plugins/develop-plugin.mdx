---
title: Develop a Tauri Plugin
---

## Adding Commands

Commands are defined in the `commands.rs` file. They are regular Tauri applications commands, so they can access the AppHandle and Window instances,
directly access state and take input the same way as application commands.

This command shows how to get access to the AppHandle and Window instance via dependency injection, and take two input parameters `on_progress` and `url`:

```rust
use tauri::{command, ipc::Channel, AppHandle, Runtime, Window};

#[command]
async fn upload<R: Runtime>(app: AppHandle<R>, window: Window<R>, on_progress: Channel, url: String) {
  // implement your command logic here
  on_progress.send(100).unwrap();
}
```

To actually expose the command to the webview, you must hook it on the `invoke_handler()` call on `lib.rs`:

```rust
Builder::new("<your-plugin-name-here>")
    .invoke_handler(tauri::generate_handler![commands::upload])
```

Now let's define a binding function on `webview-src/index.ts` so the plugin users can easily call that command:

```js
import { invoke, Channel } from '@tauri-apps/api/tauri'

export async function upload(url: string, onProgressHandler: (progress: number) => void): Promise<void> {
  const onProgress = new Channel<number>()
  onProgress.onmessage = onProgressHandler
  await invoke('plugin:<your-plugin-name-here>|upload', { url, onProgress })
}
```

Note that you must replace `<your-plugin-name-here>` with your actual plugin name so Tauri can reach your command.

When you are done implementing the command and want to test it out, don't forget to transpile the TypeScript code:

<Tabs>
  <TabItem label="npm">

    ```sh
    npm install
    npm run build
    ```

  </TabItem>
  <TabItem label="Yarn">

    ```sh
    yarn install
    yarn build
    ```

  </TabItem>
  <TabItem label="pnpm">

    ```sh
    pnpm install
    pnpm build
    ```

  </TabItem>
</Tabs>

## Managing State

A plugin can manage state the same way a Tauri application does.

- Define a state struct and let Tauri manage it:

```rust
use std::{collections::HashMap, sync::Mutex};
use tauri::{Manager, plugin::Builder};

#[derive(Default)]
struct Store(Mutex<HashMap<usize, String>>);

Builder::new("<your-plugin-name-here>")
  .setup(|app, api| {
    app.manage(Store::default());

    // retrieve the store later
    let store = app.state::<Store>();
    Ok(())
  })
```

- Access state inside a command

```rust
use tauri::{command, AppHandle, Runtime};
use crate::Store;

#[command]
fn do_something<R: Runtime>(app: AppHandle<R>, store: State<'_, Store>) {}
```

{/* TODO: link to state guide */}

## Exposing Rust APIs

The plugin APIs defined in your project's `desktop.rs` and `mobile.rs` are exported to the users as a struct with the same name as your plugin, in pascal case.
When the plugin is setup, an instance of this struct is created and managed as a state so users can retrieve it at any point of time with a Manager instance (an AppHandle, App or Window instance)
through the extension trait defined in the plugin.

For instance, the global-shortcut plugin defines a GlobalShortcut struct that can be read by using the `global_shortcut` method of the `GlobalShortcutExt` trait:

```rust
use tauri_plugin_global_shortcut::GlobalShortcutExt;

tauri::Builder::default()
  .plugin(tauri_plugin_global_shortcut::init())
  .setup(|app| {
    app.global_shortcut().register(...);
    Ok(())
  })
```

### Desktop vs Mobile Implementations

The default template splits the plugin's implementation into two separate modules, `desktop.rs` and `mobile.rs`.

The desktop implementation uses Rust code to implement a functionality, while the mobile one sends a message to the native mobile code to execute a function and get a result back.
If you need to share logic across both implementations, you can define shared functions on `lib.rs`:

```rust
use tauri::Runtime;

impl<R: Runtime> <your-plugin-name-here;pascal-case><R> {
  pub fn do_something(&self) {
    // do something that is a shared implementation between desktop and mobile
  }
}
```

This implementation simplifies the process of sharing an API that can be used both by commands and Rust code.

## Mobile

Plugins can run native mobile code written in Kotlin (or Java) and Swift.
The default plugin template includes an Android library project using Kotlin and a Swift package
including an example mobile command and how to trigger its execution from Rust code.

### Adding Mobile Support to an Existing Plugin

If you have an existing plugin and would like to add Android or iOS capabilities to it,
you can use the [`plugin android add`](/2/reference/cli#plugin-android-add) and [`plugin ios add`](/2/reference/cli#plugin-ios-add) commands
to bootstrap the mobile library projects and guide you through the changes needed.

Alternatively, consider bootstrapping a new plugin template with the v2 CLI which by default includes all code required to run native mobile code on a plugin.

### Android

For the complete documentation on writing Android plugins, see [the guide](./develop-plugin-android).

### iOS

For the complete documentation on writing iOS plugins, see [the guide](./develop-plugin-ios).

### Adding Commands on Mobile

Inside the respective mobile projects, you will find a plugin class where you can define commands that can be called by the Rust code.

- Android

```java
@TauriPlugin
class ExamplePlugin(private val activity: Activity): Plugin(activity) {
  @Command
  fun openCamera(invoke: Invoke) {
    val allowEdit = invoke.getBoolean("allowEdit", false)
    val quality = invoke.getInt("quality", 100)

    val ret = JSObject()
    ret.put("path", "/path/to/photo.jpg")
    invoke.resolve(ret)
  }
}
```

- iOS

```swift
class ExamplePlugin: Plugin {
	@objc public func openCamera(_ invoke: Invoke) {
    let allowEdit = invoke.getBool("allowEdit", false)
    let quality = invoke.getInt("quality", 100)

    invoke.resolve(["path": "/path/to/photo.jpg"])
	}
}
```

### Calling Mobile Commands

Your plugin API struct stores a [`tauri::plugin::PluginHandle`](https://docs.rs/tauri/2.0.0-alpha/tauri/plugin/struct.PluginHandle.html) that can be used to call a mobile command:

```
use std::path::PathBuf;
use serde::{Deserialize, Serialize};
use tauri::Runtime;

#[derive(Serialize)]
#[serde(rename_all = "camelCase")]
pub struct CameraRequest {
  quality: usize,
  allow_edit: bool,
}

#[derive(Deserialize)]
pub struct Photo {
  path: PathBuf,
}


impl<R: Runtime> <your-plugin-name-here;pascal-case><R> {
  pub fn open_camera(&self, payload: CameraRequest) -> crate::Result<Photo> {
    self
      .0
      .run_mobile_plugin("openCamera", payload)
      .map_err(Into::into)
  }
}
```
